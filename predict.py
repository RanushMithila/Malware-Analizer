import pefile
import math
import joblib
import sys  # Import the sys module for handling 'inf' values


def calculate_entropy(data):
    if not data:
        return 0
    entropy = 0
    for x in range(256):
        p_x = float(data.count(x)) / len(data)
        if p_x > 0:
            entropy += - p_x * math.log(p_x, 2)
    return entropy


def extract_features(software_path):
    try:
        # Initialize an empty list to store the extracted features
        features = []

        # Open the software file using pefile (Portable Executable file format parser)
        pe = pefile.PE(software_path)

        # Initialize variables to store feature values
        sections_max_entropy = 0
        version_info_size = 0
        resources_max_entropy = 0
        resources_min_entropy = float(1e10)
        sections_entropy_sum = 0
        num_sections = 0

        # Iterate through sections
        for section in pe.sections:
            # Calculate entropy for each section
            entropy = calculate_entropy(section.get_data())

            # Update features
            sections_max_entropy = max(sections_max_entropy, entropy)
            sections_entropy_sum += entropy
            num_sections += 1

        # Calculate mean entropy for sections
        sections_mean_entropy = sections_entropy_sum / num_sections

        # Extract version information size
        # Use the sizeof attribute of VS_FIXEDFILEINFO structure
        version_info = pe.VS_FIXEDFILEINFO[0]
        if version_info:
            version_info_size = version_info.sizeof()

        # Extract resources and calculate entropy
        for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
            for resource in resource_type.directory.entries:
                if hasattr(resource, 'data'):
                    data = resource.data.struct.get_data()
                    entropy = calculate_entropy(data)
                    resources_max_entropy = max(resources_max_entropy, entropy)
                    resources_min_entropy = min(resources_min_entropy, entropy)

        # Initialize sections_min_entropy to positive infinity
        sections_min_entropy = float('inf')
        # Iterate through the sections in the PE file
        for section in pe.sections:
            # Calculate the entropy for the current section
            entropy = calculate_entropy(section.get_data())

            # Update sections_min_entropy if the calculated entropy is smaller
            sections_min_entropy = min(sections_min_entropy, entropy)

        # Extract the desired features
        features.append(pe.OPTIONAL_HEADER.DllCharacteristics)
        features.append(pe.FILE_HEADER.Machine)
        features.append(pe.FILE_HEADER.Characteristics)
        # VersionInformationSize
        features.append(version_info_size)
        features.append(pe.OPTIONAL_HEADER.Subsystem)
        features.append(pe.OPTIONAL_HEADER.ImageBase)
        # SectionsMaxEntropy
        features.append(sections_max_entropy)
        features.append(pe.FILE_HEADER.SizeOfOptionalHeader)
        # ResourcesMaxEntropy
        features.append(resources_max_entropy)
        features.append(pe.OPTIONAL_HEADER.MajorSubsystemVersion)
        # ResourcesMinEntropy
        features.append(resources_min_entropy)
        features.append(pe.OPTIONAL_HEADER.MajorOperatingSystemVersion)
        # SectionsMinEntropy
        features.append(sections_min_entropy)

        # Close the PE file
        pe.close()
        return features

    except Exception as e:
        print(f"Error extracting features: {str(e)}")
        return None


loaded_classifier = joblib.load('grad_boost.pkl')
